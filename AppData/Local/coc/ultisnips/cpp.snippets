extends c

snippet class "class template" b
class ${1:Name}
{
private:

public:
    $1();
    ~$1();
};
endsnippet

snippet templatef "function template"
template <typename T>
${1:void Swap(T &a, T&b);}
endsnippet

snippet vector "vector template"
vector<${1:type}> ${2:name};
endsnippet

snippet iterator "contains iterator"
${1:array<int, 4>}::iterator ${2:p};
endsnippet

snippet lambda "lambda function template"
[] (${1:param}) -> ${2:return_type} { ${3:code}}
endsnippet

snippet point "智能指针"
std::${1:unique}_ptr<std::${2:type}> ${point_name} {new std::$2 {"example"} };
endsnippet

snippet qtlog "qt log"
#include <QtGlobal>
#include <QtDebug>
#include <QTextStream>
#include <QTextCodec>
#include <QLocale>
#include <QTime>
#include <QFile>

const QString logFilePath = "debug.log";
bool          logToFile   = false;

void customMessageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    QHash<QtMsgType, QString> msgLevelHash({{QtDebugMsg, "Debug"}, {QtInfoMsg, "Info"}, {QtWarningMsg, "Warning"}, {QtCriticalMsg, "Critical"}, {QtFatalMsg, "Fatal"}});
    QByteArray                localMsg         = msg.toLocal8Bit();
    QTime                     time             = QTime::currentTime();
    QString                   formattedTime    = time.toString("hh:mm:ss.zzz");
    QByteArray                formattedTimeMsg = formattedTime.toLocal8Bit();
    QString                   logLevelName     = msgLevelHash[type];
    QByteArray                logLevelMsg      = logLevelName.toLocal8Bit();

    if(logToFile)
    {
        QString txt = QString("%1 %2: %3 (%4)").arg(formattedTime, logLevelName, msg, context.file);
        QFile   outFile(logFilePath);
        outFile.open(QIODevice::WriteOnly | QIODevice::Append);
        QTextStream ts(&outFile);
        ts << txt << endl;
        outFile.close();
    }
    fprintf(stderr, "%s %s: %s (%s:%u, %s)\n", formattedTimeMsg.constData(), logLevelMsg.constData(), localMsg.constData(), context.file, context.line, context.function);
    fflush(stderr);

    if(type == QtFatalMsg)
        abort();
}
// qInstallMessageHandler(customMessageOutput);
endsnippet

snippet thread_template "thread use template"
//1. thread head file
#pragma once
#include <QObject>
#include <QDebug>

class ${1:Worker} : public QObject
{
    Q_OBJECT

private:
    int	m_cnt;

public:
    $1(QObject* parent = Q_NULLPTR);
    ~$1();

private slots:
    void process();

/*  自定义信号
signals:
    void error(const QString& error);
*/
};

// 2. thread implementation

#include "$1.h"

$1::$1(QObject* parent /* = Q_NULLPTR*/)
    : m_cnt(1)
{
}

Worker::~Worker()
{
    qDebug() << "~Worker()";
}

void Worker::process()
{
    while(1) // 不一定需要一直在这循环
    {
        // user code, 新线程的主要工作内容
    }
}


// 3. 界面的构造函数里声明, 并启动线程
$1*  worker = new $1;
QThread* $1thread = new QThread;
worker->moveToThread($1thread);
$1thread.start();
endsnippet
