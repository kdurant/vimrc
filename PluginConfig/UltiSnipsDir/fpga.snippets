snippet co      "comment always block"
/*-------------------------------------------------------------------------
//description   : ${1}
//parameter     :
//others        :
-------------------------------------------------------------------------*/
endsnippet

#module`!v strftime("%Y-%m-%d")`
#module ${1:/*module*/}
snippet mo      "modele without parameter"
\`timescale  1 ns/1 ps

module `!v expand('%:r')`
(
    input   wire                clk,
    input   wire                rst,
    ${1:/*port*/}
);

endmodule
endsnippet

#module ${1:/*module*/} #
snippet mod  "modele with parameter"
module `!v expand('%:r')` #
(
    ${1:/*parameter*/}
)
(
    input   wire                clk,
    input   wire                rst,
    ${2:/*port*/}
);

endmodule
endsnippet

snippet clk     "generate clock"
reg                     ${1:clk} = 0;
always
    #(1s/${2:freq}/2) $1 = ~$1;
endsnippet

snippet rst "generate reset" 
reg                     ${1:rst} = 0;
initial
begin
    #1us; $1 = 1;
    #1us; $1 = 0;
end
endsnippet

snippet ifb "if...begin...end"
if(${1:/*condition*/})
begin
    ${2:/*code*/}
end
endsnippet

snippet if "if..."
if(${1:/*condition*/})
    ${2:/*code*/}
endsnippet

snippet ifrb "if(~rst)...begin...end"
if(~rst)
begin
    ${1:/*code*/}
end
endsnippet

snippet ifr "if(~rst)..."
if(~rst)
    ${1:/*code*/}
endsnippet

snippet el  "else..."
else
    ${1:code}
endsnippet

snippet elb "else...begin...end"
else
begin
    ${1:/*code*/}
end
endsnippet

snippet eib "else if...begin...end"
else if(${1:/*condition*/})
begin
    ${2:/*code*/}
end
endsnippet

snippet ei "else if...begin...end"
else if(${1:/*condition*/})
    ${2:/*code*/}
endsnippet

snippet as  "assign ..."
assign                  ${1:LHS} = ${2:RHS};
endsnippet

snippet pa  "paramter ..."
parameter               ${1:LHS} = ${2:RHS};
endsnippet

snippet lo  "localparam ..."
localparam              ${1:LHS} = ${2:RHS};
endsnippet

snippet inout   "inout declaration"
tri [7:0] ${1:nand_data} = 100'bz;
assign (weak1, weak0) $1 = 0;
endsnippet

snippet edge "detect edge"
reg    [1:0]            ${1:Reg}_r;
wire                    $1_rise;
wire                    $1_fall;

assign          $1_rise = $1_r[1:0] == 2'b01;
assign          $1_fall = $1_r[1:0] == 2'b10;
always @ (posedge clk or negedge rst)
begin
    if(~rst)
        $1_r    <= 2'b00;
    else
        $1_r    <= {$1_r[0], $1};
end
endsnippet

snippet ini "initial ... begin ... end"
initial
begin
    ${1:/*code*/}
end
endsnippet

#case
snippet ca      "case ... endcase"
case (${1:/*condition*/})
${2:/*first*/}:
begin
    ${3:/*code*/}
end
${4:/*code*/}
default:
begin
    ${5:/*code*/}
end
endcase
endsnippet

snippet ?
${1:/*LHS*/} = ${2:/*condition*/} ? ${3:/*expr1*/} : ${4:/*expr2*/};
endsnippet

snippet be  "beging...end"
begin
    ${1:/*code*/}
end
endsnippet

snippet for     "for loop"
for(int i = 0; i < ${1:num}; i = i + 1 )
begin
    ${2:/*code*/}
end
endsnippet

#repeat
snippet repeat      "repeat loop"
repeat(${1:Number})
begin
    ${2:/*code*/}
end
endsnippet

#forever
snippet forever     "forever"
forever
    #CLKPRIEOD  clk = ~clk;         //only use initial block
endsnippet

snippet `t      "timescale"
\`timescale 1 ns/1 ps

endsnippet

snippet `d
\`define          DELAY   1

endsnippet

snippet $di
$display("${1:format}", ${2:variable});
endsnippet

snippet axis_master "axi stream master"
output  reg                 m_axis_tvalid,
output  reg                 m_axis_tlast,
input   wire                m_axis_tready,
output  reg  [${1:07}:00]        m_axis_tdata,
endsnippet

snippet axis_slave "axi stream slave"
input   wire                s_axis_tvalid,
input   wire                s_axis_tlast,
output  wire                s_axis_tready,
input   wire [${1:07}:00]        s_axis_tdata,
endsnippet


snippet string "state machine string"
// synthesis translate_off
reg [127:0] cs_STRING;
always @(*)
begin
    case(1'b1)
        cs[IDLE]: cs_STRING = "IDLE";
        default: cs_STRING = "XXXX";
    endcase
end
// synthesis translate_on
endsnippet

snippet clogb2
/* 
 * 2^x = bit_depth, return x
 */
function integer clogb2 (input integer size);
    begin
      size = size - 1;
      for (clogb2=1; size>1; clogb2=clogb2+1)
        size = size >> 1;
    end
  endfunction // clogb2
endsnippet
