#可综合部分
snippet /*
/*
 * ${1}
 */
endsnippet

snippet co
/*-------------------------------------------------------------------------
//description   :   ${1}
//condition     :
//others        :
-------------------------------------------------------------------------*/
endsnippet

snippet mo
\`timescale  1 ns/1 ps

module `!v expand('%:r')`
(
    input   logic               clk,
    input   logic               rst,
    ${1:/*port*/}
);

endmodule
endsnippet

#module ${1:/*module*/} #
snippet mod  "parameter"
module `!v expand('%:r')` #
(
    ${1:/*parameter*/}
)
(
    input   logic               clk,
    input   logic               rst,
    ${2:/*port*/}
);

endmodule
endsnippet

snippet ff "sequential logic"
always_ff @ (posedge ${1:clk} or negedge ${2:rst})
begin
    ${3:/*code*/}
end

endsnippet

snippet comb "combination logic"
always_comb
begin
    ${1:/*code*/}
end
endsnippet

snippet latch "D latch"
always_latch
begin
    ${1:/*code*/}
end
endsnippet

snippet ifb "if...begin...end"
if(${1:/*condition*/})
begin
    ${2:/*code*/}
end
endsnippet

snippet if "if..."
if(${1:/*condition*/})
    ${2:/*code*/}
endsnippet

snippet ifrb "if(~rst)...begin...end"
if(~rst)
begin
    ${1:/*code*/}
end
endsnippet

snippet ifr "if(~rst)..."
if(~rst)
    ${1:/*code*/}
endsnippet

snippet el  "else..."
else
    ${1:code}
endsnippet

snippet elb "else...begin...end"
else
begin
    ${1:/*code*/}
end
endsnippet

snippet eib "else if...begin...end"
else if(${1:/*condition*/})
begin
    ${2:/*code*/}
end
endsnippet

snippet ei "else if...begin...end"
else if(${1:/*condition*/})
    ${2:/*code*/}
endsnippet

snippet inside "a inside x"
${1:/*var*/} inside ${2:/*var*/}
endsnippet

snippet log  "logic"  
logic                       ${1:inport};
endsnippet

snippet logb "logic  [xx:00]"
logic   [${1:MSB}:00]             ${2:inport};
endsnippet

snippet in      "input logic  inport"
input   logic               ${1:inport},
endsnippet

snippet inb     "input wire [MSB:0] inport"
input   logic   [${1:MSB}:00]     ${2:inport},
endsnippet

#output
snippet our    "logic  xxx"
output  logic               ${1:outport},
endsnippet

snippet outr    "logic  [MSB:00]"
output  logic   [${1:MSB}:00]     ${2:outport},
endsnippet

snippet package
package ${1:name}
endpackage
endsnippet

snippet as  "assign ..."
assign                  ${1:LHS} = ${2:RHS};
endsnippet

snippet pa  "paramter ..."
parameter               ${1:LHS} = ${2:RHS};
endsnippet

snippet lo  "localparam ..."
localparam              ${1:LHS} = ${2:RHS};
endsnippet

snippet edge "detect edge"
reg    [1:0]            ${1:Reg}_r;
wire                    $1_rise;
wire                    $1_fall;

assign          $1_rise = $1_r[1:0] == 2'b01;
assign          $1_fall = $1_r[1:0] == 2'b10;
always @ (posedge clk or negedge rst)
begin
    if(~rst)
        $1_r    <= 2'b00;
    else
        $1_r    <= {$1_r[0],$1};
end
endsnippet

snippet ini "initial ... begin ... end"
initial
begin
    ${1:/*code*/}
end
endsnippet
#仿真部分
snippet array "fixed width"
${1:int} name[0:${2:row}];
endsnippet

snippet array_mul "fixed width"
${1:int} name[0:${2:row}][0:${3:col}];
endsnippet

snippet queue

${1:int} ${2:name}[$] ${3:= {3,4}};

endsnippet

snippet interface
interface ${1:name_if}
(
    input logic clk,
    input logic rst,
);
/*
    wire xxx;
    logic xxx;
*/
endinterface: $1
endsnippet

snippet modport
modport ${1:name_mp}
(${2}
// clocking clocking_cb,
// input input_name,
// output output_port,
// ....
);
endsnippet

snippet enum
enum ${1:/*[optional data type]*/}
{
    ${2:/*name1 = value1*/,}
} ${3:var_name};
endsnippet

snippet tde
typedef enum
{
    /*data*/,
}${1:/*enum*/}_e;
endsnippet

snippet tds
typedef struct packed
{
    /*data*/;
}${1:/*struct*/}_s;
endsnippet

snippet tdu
typedef union packed
{
    /*data*/;
}${1:/*union*/}_u;
endsnippet

snippet foreach
foreach(${1:name}[${2:index}])
endsnippet

snippet fork
initial
begin
    fork
        begin
        ${1:/*code_block1()*/}
        end
        begin
        /*code_block2()*/
        end
    join/*_any or _none*/
end
endsnippet

snippet class
class ${1:class_name} extends ${2:base_class};
    /*class property*/
    $2
    /*class method*/
    function new(/*parameter*/);
        //this.x = x;
    endfunction
endclass
endsnippet

snippet clocking
clocking ${1:cb} @ (posedge clk);
    //default input #1ns output #1ns;
    // port list
endclocking
endsnippet

snippet assert
assert("condition")
else
    $error("failed");
endsnippet

