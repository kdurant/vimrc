extends fpga

snippet `in
\`include "${1:uvm_macros.svh}"
endsnippet

#可综合部分
snippet im  "import package"
import   ${1:uvm_pkg}::*;
endsnippet
snippet /*
/*
 * ${1}
 */
endsnippet


snippet ff "sequential logic"
always_ff @ (posedge ${1:clk} or negedge ${2:rst})
begin
    ${3:/*code*/}
end

endsnippet

snippet comb "combination logic"
always_comb
begin
    ${1:/*code*/}
end
endsnippet

snippet latch "D latch"
always_latch
begin
    ${1:/*code*/}
end
endsnippet

snippet inside "a inside x"
${1:/*var*/} inside ${2:/*var*/}
endsnippet

snippet log  "logic"
logic                       ${1:inport};
endsnippet

snippet logb "logic  [xx:00]"
logic   [${1:MSB}:00]             ${2:inport};
endsnippet

snippet in      "input logic  inport"
input   logic               ${1:inport},
endsnippet

snippet inb     "input wire [MSB:0] inport"
input   logic   [${1:MSB}:00]     ${2:inport},
endsnippet

#output
snippet our    "logic  xxx"
output  logic               ${1:outport},
endsnippet

snippet outr    "logic  [MSB:00]"
output  logic   [${1:MSB}:00]     ${2:outport},
endsnippet

snippet package
package ${1:name};
endpackage
endsnippet

snippet state   "one hot encode machine state"
localparam              IDLE    = 0;
localparam              OVER    = 1;
(* KEEP = "TRUE" *)reg    [OVER:00]        cs = 'd1, ns = 'd1;
reg     [15:00]         state_cnt;

// synthesis translate_off
reg [127:0] cs_STRING;
always @(*)
begin
    case(1'b1)
        cs[IDLE]: cs_STRING = "IDLE";
        cs[HEAD]: cs_STRING = "HEAD";
        default: cs_STRING = "XXXX";
    endcase
end
// synthesis translate_on

always_ff @(posedge clk)
begin
    if(rst)
        cs <= 'd1;
    else
        cs <= ns;
end

always_comb @(*)
begin
    ns = 'd0;
    case(1'b1)
        cs[IDLE]:
        begin
            if(/*condition*/)
                ns[/*next_state*/] = 1'b1;
            else
                ns[IDLE] = 1'b1;
        end
        cs[HEAD]:
        begin
            if(/*condition*/)
                ns[/*next_state*/] = 1'b1;
            else
                ns[HEAD] = 1'b1;
        end
        default:
            ns[IDLE] = 1'b1;
    endcase
end


always_ff @ (posedge clk)
begin
    if(rst)
    begin
    end
    else
    begin
        case (1'b1)
            ns[IDLE]:
            begin
                /*code*/
            end
            /*code*/
            default:
            begin
                /*code*/
            end
        endcase
    end
end

always_ff @ (posedge clk)
begin
    if(rst)
        state_cnt <= 0;
    else if (cs != ns)
        state_cnt <= 0;
    else
        state_cnt <= state_cnt + 1'b1;
end
endsnippet

#######################################################################
######################   SIM          #################################
#######################################################################
snippet @
@ (posedge clk);
endsnippet

snippet array "unpacked array"
${1:type} name[${2:msb}:0];
endsnippet

snippet array "packed array"
${1:type} [${2:msb}:0]name;
endsnippet

snippet queue
${1:int} ${2:name}[$] ${3:= {3,4}};
endsnippet

snippet interface
interface ${1:name_bfm};
(
    input logic clk,
    input logic rst,
);
/*
    wire xxx;
    logic xxx;
*/
endinterface: $1
endsnippet

snippet clocking
clocking ${1:cb} @ (posedge clk);
$2
endclocking
endsnippet

snippet modport
modport ${1:master}
(
    input                       ${2:clk},
);
endsnippet

snippet enum
enum ${1:/*[optional data type]*/}
{
    ${2:/*name1 = value1*/,}
} ${3:var_name};
endsnippet

snippet tde
typedef enum
{
    /*data*/,
}${1:/*enum*/}_e;
endsnippet

snippet tds
typedef struct packed
{
    /*data*/;
}${1:/*struct*/}_s;
endsnippet

snippet tdu
typedef union packed
{
    /*data*/;
}${1:/*union*/}_u;
endsnippet

snippet foreach
foreach(${1:name}[${2:index}])
endsnippet

snippet fork
fork
    begin
    ${1:/*code_block1()*/}
    end
    begin
    /*code_block2()*/
    end
join/*_any or _none*/
endsnippet

snippet task
task ${1:name}($2);
    $3
endtask
endsnippet

snippet fun
function ${1:void} ${2:name}($3);
endfunction
endsnippet

snippet class   "base class"
class ${1:`!v expand('%:r')`};
    /*
     * 静态属性
     */
    function new(/*parameter*/);
        //this.x = x;
    endfunction
endclass
endsnippet

snippet extend  "extend class"
class ${1:`!v expand('%:r')`} extends ${2:uvm_component};
    function new(/*parameter*/);
        //this.x = x;
    endfunction
endclass
endsnippet

snippet uvm  "uvm extend class"
class ${1:class_name} extends ${2:uvm_component};
\`uvm_component_utils($1);
    function new (string name, uvm_component parent);
        super.new(name, parent);
    endfunction
endclass
endsnippet

snippet assert
assert("condition")
else
    $error("failed");
endsnippet

snippet $ra
${1:veriable} = $urandom_range(0, 255);
endsnippet

snippet cover
endsnippet

snippet mail
endsnippet

#######################################################################
######################   UVM          #################################
#######################################################################

snippet uvm_info
\`uvm_info("`!v expand('%:r')`", "${1:info}", UVM_LOW);
endsnippet

snippet set
uvm_config_db#(virtual ${1:interface})::set(null, "*", "bfm", bfm);
endsnippet

snippet get
uvm_config_db#(virtual ${1:interface})::get(this, "*", "bfm", bfm);
endsnippet

snippet `ifn "`ifndef ... `define ... `endif"
\`ifndef `!v toupper(expand('%:r'))`_SVH
\`define `!v toupper(expand('%:r'))`_SVH
$1
\`endif
endsnippet

snippet build_phase
virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    \`uvm_info("dut_driver", "bulid phase is called", UVM_LOW);

    if(!uvm_config_db #(virtual dut_bfm)::get(this, "", "bfm", bfm))
        \`uvm_fatal("dut_driver", "virtual interface must be set for bfm");
endfunction: build_phase
endsnippet

snippet main_phase
virtual task main_phase(uvm_phase phase);
    phase.raise_objection(this);
    \`uvm_info("dut_driver", "main phase is called", UVM_LOW);
    $1
    phase.drop_objection(this);
endtask:main_phase
endsnippet

snippet connect_phase
virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
endfunction
endsnippet
