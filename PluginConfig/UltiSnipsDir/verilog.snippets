snippet /*
/*
 * ${1}
 */
endsnippet

snippet co
/*-------------------------------------------------------------------------
//description   :   ${1}
//condition     :
//others        :
-------------------------------------------------------------------------*/
endsnippet
#module`!v strftime("%Y-%m-%d")`
#module ${1:/*module*/}
snippet mo
\`timescale  1 ns/1 ps

module `!v expand('%:r')`
(
    input   wire                clk,
    input   wire                rst,
    ${1:/*port*/}
);

endmodule
endsnippet

#module ${1:/*module*/} #
snippet mod  "wait"
module `!v expand('%:r')` #
(
    ${1:/*parameter*/}
)
(
    input   wire                clk,
    input   wire                rst,
    ${2:/*port*/}
);

endmodule
endsnippet

snippet clk
reg                     ${1:clk} = 0;
always
    #(1s/${2:freq}/2) $1 = ~$1;
endsnippet
#always
snippet al
always @ (posedge ${1:clk} or negedge ${2:rst})
begin
    ${3:/*code*/}
end
endsnippet

#always
# If Condition
snippet ifb "if...begin...end"
if(${1:/*condition*/})
begin
    ${2:/*code*/}
end
endsnippet

snippet if "if..."
if(${1:/*condition*/})
    ${2:/*code*/}
endsnippet

snippet ifrb "if(~rst)...begin...end"
if(~rst)
begin
    ${1:/*code*/}
end
endsnippet

snippet ifr "if(~rst)..."
if(~rst)
    ${1:/*code*/}
endsnippet

snippet el  "else..."
else
    ${1:code}
endsnippet

snippet elb "else...begin...end"
else
begin
    ${1:/*code*/}
end
endsnippet

snippet eib "else if...begin...end"
else if(${1:/*condition*/})
begin
    ${2:/*code*/}
end
endsnippet

snippet ei "else if...begin...end"
else if(${1:/*condition*/})
    ${2:/*code*/}
endsnippet

#input
snippet in      "input wire  inport"
input   wire                ${1:inport},
endsnippet

snippet inb     "input wire [MSB:0] inport"
input   wire [${1:MSB}:00]        ${2:inport},
endsnippet

#output
snippet our    "reg  xxx"
output  reg                 ${1:outport},
endsnippet

snippet ouw    "wire  xxx"
output  wire                ${1:outport},
endsnippet

snippet outr    "reg  [MSB:0]"
output  reg  [${1:MSB}:00]        ${2:outport},
endsnippet

snippet outb    "wire [MSB:0]"
output  wire [${1:MSB}:00]        ${2:outport},
endsnippet

#reg
snippet reg
reg                         ${1:outport};
endsnippet

snippet regb
reg     [${1:MSB}:00]             ${2:outport};
endsnippet

#wire
snippet wi      "wire   port"
wire                        ${1:port};
endsnippet

snippet wib     "wire   [MSB:0] port"
wire    [${1:MSB}:00]             ${2:port};
endsnippet

#case
snippet ca      "case ... endcase"
case (${1:/*condition*/})
${2:/*first*/}:
begin
    ${3:/*code*/}
end
${4:/*code*/}
default:
begin
    ${5:/*code*/}
end
endcase
endsnippet

snippet as  "assign ..."
assign                      ${1:LHS} = ${2:RHS};
endsnippet

snippet pa  "paramter ..."
parameter               ${1:LHS} = ${2:RHS};
endsnippet

snippet lo  "localparam ..."
localparam              ${1:LHS} = ${2:RHS};
endsnippet

snippet ;
${1:LHS} <= ${2:RHS};
endsnippet

snippet ?
${1:/*LHS*/} = ${2:/*condition*/} ? ${3:/*expr1*/} : ${4:/*expr2*/};
endsnippet

#
snippet :   "display" i
[${1:MSB}:${2:00}]
endsnippet

snippet edge "detect edge"
reg    [1:0]            ${1:Reg}_r;
wire                    $1_rise;
wire                    $1_fall;

assign          $1_rise = $1_r[1:0] == 2'b01;
assign          $1_fall = $1_r[1:0] == 2'b10;
always @ (posedge clk or negedge rst)
begin
    if(~rst)
        $1_r    <= 2'b00;
    else
        $1_r    <= {$1_r[0], $1};
end
endsnippet

snippet <<  "left shift"
${1:new_data}[7:0] <= {$1[${2:6}:${3:0}], ${4:data_in}};             // 最先进来的数据在最高位
endsnippet

snippet >>  "right shift"
${1:new_data}[7:0] <= {${3:data_in}, $1[${2:7}:${4:1}]};             // 最先进来的数据在最低位
endsnippet

# begin
snippet be
begin
    ${1:/*code*/}
end
endsnippet

snippet mem     "reg [7:0] mem[0:255]"
reg     [7:0]           mem[0:255];
endsnippet

snippet @
@(posedge clk);
endsnippet

# initial
snippet ini "initial ... begin ... end"
initial
begin
    ${1:/*code*/}
end
endsnippet

#for
snippet for
for(int i = 0; i < ${1:num}; i = i + 1 )
begin
    ${2:/*code*/}
end
endsnippet

#repeat
snippet repeat
repeat(${1:Number})
begin
    ${2:/*code*/}
end
endsnippet

#forever
snippet forever
forever
    #CLKPRIEOD  clk = ~clk;         //only use initial block
endsnippet

#task prototype
snippet task
task ${1:/*task_name*/};
    ${2:/*port declaration*/}
    begin
        ${3:/*code*/}
    end
endtask
endsnippet

snippet hr
task reset;
input   [7:0]   low_time;
begin
    rst = 1'b1;
    wait (clk !== 1'bx);
    @ (negedge clk);
    rst <= 1'b0;
    repeat(low_time)
        @ (negedge clk);
    rst <= 1'b1;
end
endtask
endsnippet

#function prototype
snippet fun
function ${1:/*return_type_or_scope*/} ${2:/*function_name*/}
    ${3:/*port declaration*/}
    begin
        ${3:/*code*/}
    end
endfunction
endsnippet

#preprocess
snippet `if  "precompile"
\`ifdef Simulation
    ${1:/*code*/}
\`endif
endsnippet

snippet `ife
\`ifdef Simulation
    ${1:/*code*/}
\`else
    ${2:/*code*/}
\`endif
endsnippet
##
snippet `t
\`timescale 1 ns/1 ps

endsnippet

snippet `d
\`define          DELAY   1

endsnippet


#system function or task
#readmemh
snippet $re
reg     [7:0]   DataMem[0:31];
$readmemh("${1:/*data.txt*/}",${2:/*DataMem*/});
endsnippet

#random
snippet $ra
${1:veriable} = ({$random} % ${2:2});
endsnippet

#display
snippet $di
$display("${1:format}", ${2:variable});
endsnippet

#strobe
snippet $st
$strobe("${1:veriable} = 0${2:x}%${3:h}",$1);
endsnippet

#strobe
snippet $mo
$monitor($time,"${1:veriable} = 0${2:x}%${3:h}",$1);
endsnippet

#handle
snippet ha
integer ${1:handle};
initial
begin
    $1 = $fopen("${2:file.out}");
end
endsnippet

#fdisplay, write data to file
snippet $fdi
$fdisplay(${1:handle},"${2:veriable} = 0${3:x}%${4:h}",$2);
endsnippet

snippet inout
tri [7:0] ${1:nand_data} = 100'bz;
assign (weak1, weak0) $1 = 0;
endsnippet

#test
snippet st
reg     [3:0]           current_state, next_state;
reg     [15:0]          state_cnt;
localparam              sIdle_state = 0;
//-------------------------------------------------------------------------
//next_state滞后于current_state一个周期
//-------------------------------------------------------------------------
always @ (posedge ${1:clk} or negedge ${2:rst})         // build the state flops
begin
    if(~rst)
        current_state       <= ${3:sIdle_state};
    else
        current_state       <= ${4:next_state};
end

//-------------------------------------------------------------------------
//second.state transfer
//-------------------------------------------------------------------------
always @ ( * )      //state machine, block assign
begin
    case(current_state)
        sIdle_state:
        begin
            if(/*xx*/)
                next_state = /*xx_state*/;
            else
                next_state = current_state;
        end
        default: next_state = sIdle_state;
    endcase
end

//-------------------------------------------------------------------------
//three.output
//-------------------------------------------------------------------------
always @ (posedge $1 or negedge $2)     //output
begin
    if(~rst)
    begin
    end
    else
    begin
        case(next_state)
            sIdle_state:
            begin
            end
            default:
            begin
            end
        endcase
    end
end

/*
 * 状态跳转计数器
 */
always @ (posedge clk or negedge rst)
begin
    if(~rst)
        state_cnt <= 0;
    else if (next_state != current_state)
        state_cnt <= 0;
    else
        state_cnt <= state_cnt + 1'b1;
end
endsnippet

snippet sync
module sync
(
    input   wire                clk,
    input   wire                rst,

    input   wire                sig_in,
    output  reg                 sig_out
);

reg                     sig_reg;
always @ (posedge clk or negedge rst)
begin
    if(~rst)
    begin
        sig_out <= 0;
        sig_reg <= 0;
    end
    else
    begin
        sig_reg <= sig_in;
        sig_out <= sig_reg;
    end
end
endmodule
endsnippet

snippet prune
/* synthesis noprune */
endsnippet

snippet keep    "altera"
/* synthesis keep */
endsnippet

snippet keep    "xilinx"
(* KEEP = "TRUE" *)
endsnippet

snippet file
integer ${1:name};
initial
begin
    $1 = $fopen("${2:file}.txt");
    $fmonitor($1, "%h %t", ${3:variable}, $time);
    $fclose($1);
end
endsnippet

snippet state   "one hot encode machine state"
localparam              IDLE = 0;
localparam              OVER = 1;
(* KEEP = "TRUE" *)reg     [OVER:0]        cs = 'd1;
(* KEEP = "TRUE" *)reg     [OVER:0]        ns = 'd1;
reg     [15:0]          state_cnt;

// synthesis translate_off
reg [127:0] cs_STRING;
always @(*)
begin
    case(1'b1)
        cs[IDLE]: cs_STRING = "IDLE";
        cs[HEAD]: cs_STRING = "HEAD";
        cs[DISC]: cs_STRING = "DISC";
        default: cs_STRING = "XXXX";
    endcase
end
// synthesis translate_on
always @(posedge clk)
begin
    if(rst)
        cs <= 'd1;
    else
        cs <= ns;
end

always @(*)
begin
    ns = 'd0;
    case(1'b1)
        cs[IDLE]:
        begin
            if(/*condition*/)
                ns[/*next_state*/] = 1'b1;
            else
                ns[IDLE] = 1'b1;
        end
        cs[HEAD]:
        begin
            if(/*condition*/)
                ns[/*next_state*/] = 1'b1;
            else
                ns[HEAD] = 1'b1;
        end
        default:
            ns[IDLE] = 1'b1;
    endcase
end


always @ (posedge clk)
begin
    if(rst)
    begin
    end
    else
    begin
        case (1'b1)
            ns[IDLE]:
            begin
                /*code*/
            end
            /*code*/
            default:
            begin
                /*code*/
            end
        endcase
    end
end

always @ (posedge clk)
begin
    if(rst)
        state_cnt <= 0;
    else if (cs != ns)
        state_cnt <= 0;
    else
        state_cnt <= state_cnt + 1'b1;
end
endsnippet
