snippet co "function comment"
/**************************************************************************
 * Function     : ${1}
 * Description  :
 * Input        :
 * Return       :
 * Others       :
 *************************************************************************/
endsnippet

snippet dox "function comment"
/**
  * @brief  ${1}
  * @param
  * @note
  * @retval
  */
endsnippet

snippet title
/**
  ******************************************************************************
  * @file    `!v expand('%')`
  * @author  kdurant
  * @version V1.0.0
  * @date
  * @brief
  * @par Copyright
  ******************************************************************************
  */
endsnippet
snippet /*
/*
 * ${1}
 */
endsnippet

snippet main
int main(int argc, char *argv[])
{
    ${1:/*code*/}

    return 0;
}
endsnippet


snippet #inc    "include<...> "
#include <${1:stdio}.h>
endsnippet

snippet #in "include'...'"
#include "${1:stdio}.h"
endsnippet

snippet #de	"#define ..."
#define ${1:TEST}
endsnippet

snippet #if	"#if ... #endif"
#if ${1:DEBUG}
    ${2:}
#endif
endsnippet

snippet #ifd	"#ifdef ... #endif"
#ifdef ${1:DEBUG}
    ${2:}
#endif
endsnippet

snippet #ifn "#ifndef ... #define ... #endif"
#ifndef `!v toupper(expand('%:r'))`_H
#define `!v toupper(expand('%:r'))`_H

$1

#endif
endsnippet

snippet if	"if {...}"
if(${1:/*cond*/})
{
    ${2:/*code*/}
}
endsnippet

snippet el	"else {...}"
else
{
    ${1:/*code*/}
}
endsnippet

snippet ei "else if {...}"
else if(${1:/*cond*/})
{
    ${2:/*code*/}
}
endsnippet

snippet ?
${1:/*LHS*/} = ${2:/*cond*/} ? ${3:/*expr1*/} : ${4:/*expr2*/};
endsnippet

snippet do	"do ... while loop"
do
{
    ${2:/*code*/}
}
while (${1:/*cond*/});
endsnippet

snippet wh	"while loop"
while(${1:/*cond*/})
{
	${2:/*code*/}
}
endsnippet

snippet for	"for loop(for)"
for( ${1:i} = 0; $1 ${2:<} ${3:count}; $1${4:++} )
{
	${5:/*code*/}
}
endsnippet


snippet fun	"function define"
${1:void} ${2:/*function_name*/}(${3:/*parameter*/})
{
	${4:/*code*/}
}
endsnippet

snippet fund	"function declaration"
${1:void} ${2:/*function_name*/}(${3});
endsnippet

snippet st	"struct"
struct ${1:/*struct*/}
{
	${2:/*data*/}
};
endsnippet

snippet un	"union"
union ${1:/*union*/}
{
	${2:/*data*/}
};
endsnippet

snippet td	"typedef"
typedef ${1:int} ${2:/*MyCustomType*/};
endsnippet

snippet tdf	"typedef function point"
/*
 * typedef void (*list_op)(void*);      function point declaration
 * void print_student(void* data)       function declaration
 * void traverse(list* llist, list_op do_func)  called function declaration
 * traverse(llist, print_student);      usage
 */
typedef ${1:int} (*${2:pfun})(${3:parameter});
endsnippet

snippet tds	"typedef struct"
typedef struct __${1:/*struct*/}
{
	${2:/*data*/};
	void (*construct)(struct __$1 *this);
}$1Def;
endsnippet

snippet tde	"typedef enum"
/*
 * enum spectrum {red, orange, yellow}
 * enum spectrum color;
 * if(color == red)
 */
typedef enum __${1:name}
{
	${2:/*data1*/},
	${3:/*data2*/}
}$1Def;
endsnippet

snippet tdu	"typedef union"
typedef union __${1:name}
{
	${2:/*data1*/},
	${3:/*data2*/}
}$1Def;
endsnippet

snippet sw	"switch ... case"
switch (${1:/*cond*/})
{
	case ${2:/*select*/} :
		break;
	default:
		break;
}
endsnippet

snippet puts	"puts(const char *s)"
puts("${1:/*str*/}");
endsnippet

snippet gets	"gets(char *s)"
gets(${2:/*str*/});
endsnippet

snippet pr "printf(const char *format, ...)"
printf("${1:str}\n", ${2:variable});
endsnippet

snippet scanf
scanf("%${1:d}",&${2:/*num*/});
endsnippet

snippet fopen
${1:/*FilePoint*/} *fopen("${2:/*FileName*/}", "${3:/*OpenType*/}");
endsnippet

snippet fclose
fclose(${1:/*FilePoint*/});
endsnippet

snippet fputc
fputc('${1:/*char*/}',${2:/*FilePoint*/};
endsnippet

snippet fgetc
${1:/*char*/} = fgetc(${2:/*FilePoint*/});
endsnippet

snippet fputs
fputs('${1:/*str*/}',${2:/*FilePoint*/};
endsnippet

snippet fgets
${1:/*str*/} = fgets(${2:/*FilePoint*/});
endsnippet

snippet fprintf
fprintf(${1:/*FilePoint*/}, "${2:/*format*/}", "${3:variable}");
endsnippet

snippet fscanf
endsnippet

snippet feof
endsnippet

snippet ferror
endsnippet

snippet rewind
endsnippet

snippet remove
endsnippet

snippet fread
endsnippet

snippet fwrite
endsnippet

snippet malloc
${1:/*point*/} = (${2:int} *)malloc(${3:len}*sizeof($2));
if( $1 == NULL)
{
	//exit(1);
}
free($1);
endsnippet

snippet strcpy	"copy src to dest"
strcpy(${1:/*dest*/}, ${2:/*src*/});
endsnippet

snippet strncpy	"copy n char from src to dest"
strncpy(${1:/*dest*/}, ${2:/*src*/}, ${3:/*n*/});
endsnippet

snippet strcat	"append src to dest"
strcat(${1:/*dest*/}, ${2:/*src*/});
endsnippet

snippet strncat	"append src to dest"
strncat(${1:/*dest*/}, ${2:/*src*/}, ${3:/*n*/});
endsnippet

snippet strcmp	"compare str1 against str2"
strcmp(${1:/*str1*/}, ${2:/*str2*/});
endsnippet

snippet strcoll	"similar to strcmp()"
strcoll(${1:/*str1*/}, ${2:/*str2*/});
endsnippet

snippet strncmp	"no more than n character"
strncmp(${1:/*str1*/}, ${2:/*str2*/}, ${3:/*n*/});
endsnippet

snippet strtol	"convert str to number"
strtol(${1:/*str1*/}, (char **)NULL, ${2:10});
endsnippet

snippet strxfrm
endsnippet

snippet strchr	"returns a pointer to the located character"
strchr(${1:/*str*/}, '${2:/*char*/}');
endsnippet

snippet strcspn	"return offset of str1 that is a member of str2"
strcspn(${1:/*str1*/}, ${2:/*str2*/});
endsnippet

snippet strpbrk	"related to strcspn()"
strpbrk(${1:/*str1*/}, ${2:/*str2*/});
endsnippet

snippet strrchr	"search str from the end of str"
strrchr(${1:/*str*/}, '${2:/*char*/}');
endsnippet

snippet strspn
strspn(${1:/*str1*/}, ${2:/*str2*/});
endsnippet

snippet strtok
strtok(${1:/*str1*/}, ${2:/*str2*/});
endsnippet

snippet swab
endsnippet
snippet	rand
${1:/*rand_num*/} = rand() % ${2:/*maxnum*/};
endsnippet
snippet setbuf
setbuf(${1:stdout},${2:NULL});	//display infomation when use eclipse debug
endsnippet

snippet he
printf("hello world!\n");
endsnippet

snippet swap	"swap two variable"
void swap(int *x, int *y)
{
    int temp = *x;
	*x = *y;
	*y = t;
}
endsnippet

snippet memset	"memset(void *block, int c, size_t size)"
memset(${1:buffer}, ${2:0x00}, sizeof($1)/sizeof(${3:int}));
endsnippet

snippet pack
#pragma pack(push,1);
$1
#pragma pack(pop);
endsnippet
