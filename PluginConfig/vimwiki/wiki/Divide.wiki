= 偶数分频 =
{{{clase = "brush : verilog"
`timescale  1ns/1ps 
`define     DELAY   1 
module ClkDivideEven   #
(
    parameter    TDDR = 10 
)
(
    Clk,
    RSTn,
    pClkOut
);
input               Clk ;
input               RSTn ;
output              pClkOut ;
reg                 pClkOut ;

reg     [7:0]       rClkCount ;
always @(posedge Clk or negedge RSTn)
begin
    if(~RSTn)
    begin
        pClkOut          <=#`DELAY 0 ;
        rClkCount        <=#`DELAY 0 ;
    end
    else
    begin
        if (rClkCount == TDDR/2-1)
        begin
            pClkOut      <=#`DELAY ~pClkOut ;
            rClkCount    <=#`DELAY 0 ;
        end
        else
            rClkCount    <=#`DELAY rClkCount + 1 ;
    end
end
endmodule
  }}}
  
= 奇数分频 =
{{{clase = "brush : verilog"
`timescale  1ns/1ps 
`define     DELAY   1

//-------------------------------------------------------------------------
//Odd frequency division
//duty = 50
//-------------------------------------------------------------------------
module ClkDivideOdd     #
(
    parameter    TDDR = 5 
)
(
    CLK,
    RSTn,

    pClkOut,
);

input       CLK ; 
input       RSTn;
output      pClkOut;

reg [7:0]   rCntPositive ;
reg [7:0]   rCntNegative;

reg         rClkPositive ;
reg         rClkNegative ;

always @ (posedge CLK or negedge RSTn)
begin

    if(~RSTn)     
        rCntPositive    <=#`DELAY 0;
    else if(rCntPositive == TDDR-1)    
        rCntPositive    <=#`DELAY 0;
    else 
        rCntPositive    <=#`DELAY rCntPositive + 1;

end

always @ (posedge CLK or negedge RSTn)
begin
    if(~RSTn) 
        rClkPositive    <=#`DELAY 0;
    else if(rCntPositive == (TDDR-1)/2)
        rClkPositive    <=#`DELAY ~rClkPositive;
    else if(rCntPositive==TDDR-1)
        rClkPositive    <=#`DELAY ~rClkPositive;
end

always @ (negedge CLK or negedge RSTn)
begin
    if(~RSTn)     
        rCntNegative    <=#`DELAY 0;
    else if(rCntNegative == TDDR-1)    
        rCntNegative    <=#`DELAY 0;
    else 
        rCntNegative    <=#`DELAY rCntNegative + 1;
end

always @ (negedge CLK or negedge RSTn)
begin
    if(~RSTn) 
        rClkNegative    <=#`DELAY 0;
    else if(rCntNegative == (TDDR-1)/2)
        rClkNegative    <=#`DELAY ~rClkNegative;
    else if(rCntNegative == TDDR-1)
        rClkNegative    <=#`DELAY ~rClkNegative;
end

assign pClkOut = rClkPositive | rClkNegative;

endmodule
  }}}
  
= Testbench =
{{{clase = "brush : verilog"
`timescale  1ns/1ps 
`define     DELAY   1 

module  test_tb();
reg         Clk;
reg         RSTn;
wire        pClkOut;

initial
begin
    Clk  = 0 ;
    HarwareReset ;
end

always  #10     Clk = ~Clk ;

parameter   TDDR = 10 ;

task HarwareReset ;
    begin
        RSTn = 1'b1;
        wait (Clk !== 1'bx);
        @ (negedge Clk);
        RSTn <= 1'b0;
        @ (negedge Clk);
        @ (negedge Clk);
        RSTn <= 1'b1;
    end
endtask

ClkDivideEven 
#(
    .TDDR       (    TDDR       )
)
ClkDivideEvenEx01
(
    .Clk        (    Clk        ),
    .RSTn       (    RSTn       ),
    .pClkOut    (    pClkOut    )
);
endmodule
  }}}

