第一种方法:
遍历数组
{{{class="brush:c++"
#include <stdio.h>
#define	SIZE 10

int main(int argc, char *argv[])
{
    int a[SIZE] = {2,6,4,8,10,12,89,68,45,37} ;

    int pass ;
    int i ;
    int hold ;

    printf("Data items in original order\n") ;
    for(i = 0; i < SIZE; i++)
    {
        printf("%4d\n", a[i]) ;
    } 

    for(pass = 1; pass < SIZE; pass++)
    {
        for(i = 0; i < SIZE - 1; i++)
        {
            if(a[i] > a[i + 1])
            {
                hold = a[i] ;
                a[i] = a[i + 1] ;
                a[i + 1] = hold ;
            }
        }
    }

    puts("\nData items in ascending order\n") ;

    for(i = 0; i < SIZE; i++)
    {
        printf("%4d\n", a[i]) ;
    }
    puts("\n") ;
    return 0 ;
}
}}}
第二种方法:
增加判断条件,逐步减少比较次数,没有数据交换时,结束比较

{{{class="brush:c++"
#include <stdio.h>
#define	MAX 10

int main(int argc, char *argv[])
{
    int a[MAX] = {2,6,4,8,10,12,89,68,45,37} ;

    int pass ;
    int i  ;
    int hold ;
    int swap ;

    printf("Data items in original order\n") ;
    for(i = 0; i < MAX; i++)
    {
        printf("%4d\n", a[i]) ;
    } 

    for(pass = 1; pass < MAX; pass++)
    {
        swap = 0 ;
        for(i = 0; i < MAX - pass; i++)
        {
            if(a[i] > a[i + 1])
            {
                swap = 1 ;
                hold = a[i] ;
                a[i] = a[i + 1] ;
                a[i + 1] = hold ;
            }
        }
        printf("After Pass %d: ", pass) ;

        for(i = 0; i < MAX - pass; i++)
        {
            printf("   %d", a[i]) ;
        }
        printf("\n") ;

        if(!swap)
        {
            break ;
        }
    }

    puts("\nData items in ascending order\n") ;

    for(i = 0; i < MAX; i++)
    {
        printf("%4d\n", a[i]) ;
    }
    puts("\n") ;
    return 0 ;
}
}}}
