
= 定义数据类型 =
== 第一种 ==
{{{class="brush:c++"
struct film
{
    char title[TSIZE] ;
    int rating ;
} ;

typedef struct film Item ;      

typedef struct node
{
    Item item ;
    struct node *next ;
} Node ;                        //link node 

typedef Node * List ;           //link list 
}}}

== 第二种 ==
{{{class="brush:c++"
struct listNode
{
    char data ;
    struct listNode *nextPtr ;
} ;

typedef struct listNode ListNode ;
typedef ListNode * ListNodePtr ;
}}}

= 声明链表 =
List movies ;
为了管理链表,需要一个指向其开始处的指针,通过typedef使List成为指向Node类型的指针
的名称

movies指向一个Node型的对象

= 初始化 =
链表初始化是空的,没有成员,只需要把指针置空
{{{class="brush:c++"
InitializeList(&movies) ;
void InitializeList(List *plist)
{
    *plist = NULL ;
}
}}}

= 判断链表是否满 =
判断能否为节点分配内存
{{{class="brush:c++"
bool ListIsFull(List l)
{
   Node * pt;
   bool full;

   pt = (Node *) malloc(sizeof(Node));
   if (pt == NULL)
      full = true;
   else
      full = false;
   free(pt);
   return full;
}
}}}

= 向链表添加节点 =
{{{class="brush:c++"
bool AddItem(Item item, List *plist) 
{
    Node * pnew ;
    Node * scan = *plist ;

    pnew = (Node *)malloc( sizeof(Node) ) ;
    
    if(pnew == NULL)
        return false ;
    pnew->item = item ;
    pnew->next = NULL ; //表示该节点为链表的最后一个节点 

    if(scan == NULL) //判断传递进来的链表是否为空 
        *plist = pnew ;
    else
    {
        while(scan->next != NULL)
            scan = scan->next ; //找到链表结尾,将节点放在链表最后
        scan->next = pnew ;     
    }

    return true ;
}
}}}

= 清空链表 =
{{{class="brush:c++"
void EmptyTheList(List * plist)
{
    Node * psave ;
    while (*plist != NULL) //判断链表是不是为空 
    {
        psave = (*plist)->next ; //保存下一个节点的地址 
        free(*plist) ;
        *plist = psave ;
    }
}
}}}
