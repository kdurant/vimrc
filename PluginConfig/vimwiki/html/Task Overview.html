<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>Task Overview</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h1 id="toc_1">声明格式</h1>
<pre class="brush : verilog">
task task_id;
[declaration]
    procedural_statement
    endtask 
</pre>
<p>
其中，关键词 task 和 endtask 将它们之间的内容标志成一个任务定义，task 标志着一个
任务定义结构的开始；task_id 是任务名；可选项 declaration 是端口声明语句和变量声明语
句，任务接收输入值和返回输出值就是通过此处声明的端口进行的；procedural_statement
是一段用来完成这个任务操作的过程语句，如果过程语句多于一条，应将其放在语句块内；
endtask 为任务定义结构体结束标志。下面给出一个任务定义的实例。
</p>

<h2 id="toc_1.1">注意事项</h2>
<ol>
<li>
在第一行“task”语句中不能列出端口名称；

<li>
任务的输入、输出端口和双向端口数量不受限制，甚至可以没有输入、输出以及 双向端口。

<li>
在任务定义的描述语句中，可以使用出现不可综合操作符合语句（使用最为频繁 的就是延迟控制语句） ，但这样会造成该任务不可综合。

<li>
在任务中可以调用其他的任务或函数，也可以调用自身。

<li>
在任务定义结构内不能出现 initial和 always过程块。

<li>
在任务定义中可以出现“disable 中止语句” ，将中断正在执行的任务，但其是不可综合的。当任务被中断后，程序流程将返回到调用任务的地方继续向下执行。

</ol>

<h1 id="toc_2">任务调用</h1>
<p>
虽然任务中不能出现 initial 语句和 always 语句语句， 但任务调用语句可以在 initial 语句
和 always 语句中使用，其语法形式如下：
task_id[(端口1,  端口 2, ........,  端口 N)];
其中 task_id是要调用的任务名，端口 1、端口 2，…是参数列表。参数列表给出传入任
务的数据（进入任务的输入端）和接收返回结果的变量（从任务的输出端接收返回结果） 。
任务调用语句中，参数列表的顺序必须与任务定义中的端口声明顺序相同。任务调用语句是
过程性语句，所以任务调用中接收返回数据的变量必须是寄存器类型。下面给出一个任务调
用实例。
</p>

<h2 id="toc_2.1">注意事项</h2>
<ol>
<li>
任务调用语句只能出现在过程块内；

<li>
任务调用语句和一条普通的行为描述语句的处理方法一致；

<li>
当被调用输入、输出或双向端口时，任务调用语句必须包含端口名列表，且信号端口顺序和类型必须和任务定义结构中的顺序和类型一致。需要说明的是，任务的输出端口 必须和寄存器类型的数据变量对应。

<li>
可综合任务只能实现组合逻辑，也就是说调用可综合任务的时间为“0” 。而在面向仿真的任务中可以带有时序控制，如时延，因此面向仿真的任务的调用时间不为“0” 。

</ol>

</body>
</html>
